---
title: "哈希与堆专题"
date: 2023-02-07
math: true
image: hash-heap.jpg
tags: [ data-structure ]
comments: true
draft: false
summary: "南京大学2021级软件学院大二上学期数据结构与算法课程哈希与堆专题笔记"
---

## 哈希/散列表

### 负载因子

$Load~Factor$，也称为冲突因子，记为α，有$\alpha=\frac{数据个数}{空闲个数}$，若α>1，则发生碰撞的概率高，常数复杂度不可达；若α<1，则发生碰撞的概率相对较低，有可能达到常数复杂度

### 哈希函数

$Hash~Function$，也称为散列函数，用于从给定的数据映射到一个代表地址的数值

#### 取余法

$H(Key)=Key\mod M$，其中M是在基本区长度内的最大质数，尽可能降低冲突概率

#### 平方取中法

$H(Key)=Key^2$十进制数字表示的中间部分，其长度取决于存储数据的哈希表的大小

#### 乘法杂凑函数

$H(Key)=\lfloor M*((\phi*Key)\mod 1)\rfloor$，其中M为最大单元的下标，φ一般取为小于1的无理数，mod 1表示只保留小数部分

### 冲突处理

#### 挂载单链表

将发生冲突的值以链表的形式挂载在同一地址的哈希表下，但是一般很少用这种方式，因为整个散列表空间很大，如果将申请的空间弃置不用而为链表申请额外空间是对内存资源的浪费

#### 开放地址法

$Open~Addressing$，做法是向散列表后续的空间探测，直到发现空位置就将它存入其中，存入过程的探测时间和查找过程的探测时间成正比；当散列表中的某个数据需要删去时并不真正删掉它，而只是标记它被删去，被标记删去的数据可以被后来的数据替代，在查找过程中如果探测到空位置就认为需要查找的数据不在散列表中；如果存入某个数据后散列表中的数据条目数量大于设定值，即负载因子大于设定值，则需要扩大散列表的容量，重新进行散列(rehash)，该过程会将已经散列好的数据也重新散列，因此会带来较大的时间开销

平均搜索长度指的是假设各个数据被查找的概率相等，用查找每个数据需要的探测次数计算平均值

**线性探测法(Linear Probing)**

依次探测下一个位置，到最大值则从0继续。容易出现堆积问题(Clustering Problem)，即如果有一批数据的散列值很接近，就会导致对应内存空间的散列表被全部占满，只要再次出现散列值在其附近的数据就一定会引发冲突，继续在该空间插入数据的代价会很大

**二次探测法(Quadratic Probing)**

记当前数据的哈希值为$d$，若位置d的散列表已经被其他数据占用，则依次探测$d+1,d+2^2,d+3^2,\dots$即使用二次函数进行跳跃

**双哈希(Double Hashing)**

使用两个散列函数，先计算$Hash_1(Key)=d$，若不冲突则直接存入，否则就计算$Hash_2(Key)=c$，然后依次探测$d+c,d+2c,d+3c,\dots$

## 堆/优先队列

### 定义

可以分为大根堆和小根堆，特点分别是每个节点的键值大于等于（小于等于）它所有子节点的键值的完全二叉树，常用数组进行模拟

### 插入操作

直接插入在数组的末尾，然后进行上律，即不断与自己的父节点$num[index/2]$比较，对于大根堆来说，如果其键值大于父节点的键值，则交换父节点与其键值，小根堆同理，直到不需要交换为止

### 删除操作

堆上一般只能删除树根，在删除树根后，就用数组末尾的元素替代树根，然后进行依次下律，即不断与自己的两个子节点比较，对于大根堆来说，选择子节点中键值比自己的键值大的最大值进行交换，小根堆同理，直到不需要交换为止

### 堆的初始化

#### 直接更改原有数组

直接更改原数组的初始化又可以分为两种，分别是上律初始化和下律初始化。对于上律初始化，从第二层节点开始，依次进行上律；而对于下律初始化，则是从倒数第二层节点开始，依次进行下律。由于最高层的节点往往远远多于第一层节点，所以下律初始化的效率一般高于上律初始化

#### 依次插入

依次取出原数组中的元素，对其应用插入操作

### 应用

#### 堆排序

初始化一个大根或小根堆后，不断应用删除操作，并将删除的节点按次序记录在排序结果的数组中，时间复杂度$O(nlog_2n)$，是**不稳定排序**，即不能保证相同大小的元素在排序结果数组中按原有次序出现

#### 求第K大/小元素

使用堆操作只需要应用K或N-K次删除操作，在时间复杂度上表现良好

## 并查集优化

~~~~c++
int find(int x){
    if(up[x] == x)return x;
    return up[x] = find(up[x]);
    //每次查找就用结果更新up数组以减少下次查询的次数
}
~~~~



